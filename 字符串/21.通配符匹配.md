给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
两个字符串完全匹配才算匹配成功。

说明:

s 可能为空，且只包含从 a-z 的小写字母。
p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。
示例 1:

输入:
```
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```
示例 2:
```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串。
```
示例 3:
```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
```
示例 4:
> ```
> 输入:
> s = "adceb"
> p = "*a*b"
> 输出: true
> 解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
> ```

示例 5:
```
输入:
s = "acdcb"
p = "a*c?b"
输出: false
```





动态规划

dp\[i][j]表示字符串的第 i 及前 i 个字符和模式的第 j 及前 j 个字符是否匹配，也就是表示的是s[0 : i-1]和p[0 : j-1]的匹配情况。下面构建状态转移方程。

* 如果s[i - 1] == p[j - 1]，那么就有

​       dp\[i][j] = dp\[i - 1][j - 1]

* 如果p[j - 1] == '?'，因为问号可以匹配任何单个字符，所以有

​       dp\[i][j] = dp\[i - 1][j - 1]

* 如果p[j - 1] == '*'，星号\*可以匹配任意长度的字符串包括空字符串

​       如果星号\* 匹配空字符串，则有dp\[i][j] = dp\[i][j - 1]

​       如果星号\*匹配多个字符，则有dp\[i][j] = dp\[i - 1][j]

另外有，

​       dp\[0][0] = true，空模式和空字符串相匹配

​       dp\[i][0] = false，i > 0，空模式无法和字符串相匹配

​       dp\[0][j]，只有星号才能匹配空字符串，所以只有当j及之前字符均为星号时dp\[0][j]才为true



思考dp时要告诉自己0 ~ n - 1的结果已经知道了



```go
func isMatch(s string, p string) bool{
  // 创建二维数组，需要包括空字符在内，所以长度要各+1
  m, n := len(s), len(p);
  dp := make([][]bool, m + 1);
  for i := 0; i <= m; i++ {
    dp[i] = make([]bool, n + 1);
  }
  dp[0][0] = true;

  // dp[i][0] 都是false，创建时bool类型的零值就是false，不用处理
  // 处理dp[0][j]
  for i := 1; i <= n; i++{
    if p[i - 1] == '*'{
      dp[0][i] = true;
    } else {
      break;
    }
  }

  // [0, 0]表示空字符和空模式
  // [1, 1]才是字符和模式的开始
  for i := 1; i <= m; i++ {
    for j := 1; j <= n; j++ {
      if p[j - 1] == '*' {
        dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
      } else if p[j - 1] == '?' || p[j - 1] == s[i - 1] {
        dp[i][j] = dp[i - 1][j - 1];
      }

    }
  }
  return dp[m][n];
}
```

