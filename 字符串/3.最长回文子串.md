给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

```

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

示例 2：
```
输入: "cbbd"
输出: "bb"
```



方法：**中心扩展算法**

回文字符串一定会有个中心：

* 字符串长度为奇数，则中心为中间的字符
* 字符串长度为偶数，则中心为中间两字符的中间位置。

找出一个字符串内最长的回文子串，可以先找出所有回文子串，然后再比较大小。

逐个以现有字符串中的字符或者两字符中间位置为中心，向左右扩展，寻找回文子串。



java：

```java
// 最长回文子串
public class longestPalindromeSubstring {
  public static void mian(String[] args){
		String s = "babad";
    String s1 = "cbbd";
    System.out.println(solution(s)); // bab
    System.out.println(solution(s1)); // bb
  }
  public static String solution(String s){
    if(s == null || s.length() == 1){
      return s;
    }
    int len = 0, end = 0, start = 0;
    for (int i = 0; i < s.length(); i++){
      int len1 = expand(s, i, i); // 以 i 为中心向左右扩展寻找回文串，并返回长度
      int len2 = expand(s, i, i + 1); // 以 i 与 i+1 中间的空档为中心向左右扩展寻找回文串，并返回长度
      len = Math.max(len2, len1);
      if (len > end - start + 1){
        start = i - (len - 1) / 2;
        end = i + len / 2;
      }
    }
    return s.substring(start, end + 1);
  }

  public static int expand(String s, int left, int right){
    while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)){
      left--;
      right++;
    }
     return right - left - 1;
  }
}

```

golang：

```go
func longestPalindrome(str string) string{
  if len(str) == 0{
    return str;
  }
  longestStr := "";
  for i := range str{
    left1, right1 := expand(str, i, i);
    left2, right2 := expand(str, i, i+1);

    l := int(math.Max(float64(right1 - left1+1), float64(right2 - left2+1)));
    if l > len(longestStr){
      if right1 - left1 > right2 -left2{
        longestStr =  str[left1:right1+1];
      } else {
        longestStr = str[left2:right2 +1]
      }
    }
  }
  return longestStr;
}

// 从left，right位置分别向左右扩展，直到扩展到头部或尾部位置或者左右出现不相等
func expand(s string, left int, right int)(int, int){
  for left >=0 && right < len(s) && s[left] == s[right]{
    left--;
    right++;
  }
  // 跳出循环后左右各缩小一位
  return left+1, right-1;
}
```



