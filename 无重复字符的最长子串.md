给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```



#### 滑动窗口解法

维护一个窗口，窗口中放置着没有重复字符的子字符串，逐渐扩大子字符串的右边界，直到找到一个重复字符。

```
public static int logestSubstring(String s){
    int n = s.length();
    Set<Character> set = new HashSet<>(); // set即为我们维护的欢动窗口
    while( i < n && j < n){
        if(!set.containes(s.charAt(j))){
            set.add(s.charAt(j++)); // 将不重复的字符放到set中
            ans = Math.max(ans, j - i);
        } else {
        // 出现重复字符后，要将set中重复包括重复字符在内的重复字符之前的字符删掉
        // 然后再从重复字符之后的那个位置开始计算子字符串长度
        // 例如“abcbedf”，当遍历到第二个b位置即索引3位置时，此时set中包含了a/b/c三个字符
        // 需要将索引1（第一个字符b）及之前的的字符删掉，然后从字符c即索引2开始重新计算子字符串长度。
        
            set.remove(s.charAt(i++));
        }
    }
}
```

