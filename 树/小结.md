__题目__：假设二叉树采用二叉链存储结构，设计一个算法求二叉树b中度为2的节点个数。

__解法__：递归

```javascript
function count(node){
    if(!node){
        return 0;
    }
    if(node.left && node.right){
        return count(node.left) + count(node.right) + 1;
    } else {
        return count(node.left) + count(node.right);
    }
}
```



__题目__：假设二叉树采用二叉链存储结构，设计一个算法求二叉树b中第k层的节点个数

__解法__：递归

```javascript
function knumber(node, h, k, n){ // node为根节点，h为node所处层次, n用来存储节点个数
    if(!node){
        return;
    }
    if(h == k){ // 当前访问节点在第k层，n增加1
        n++;
    } else if( h < k){ // 若当前节点层次小于k，递归处理左右子树
        knumber(node.left, h + 1, k, n);
        knumber(node.right, h + 1, k, n);
    }
    return n;
}
```



__题目__：假设二叉树采用二叉链存储结构，设计一个算法求二叉树b的宽度（最宽那层的节点个数）。

__解法__：递归

```javascript
// 先把各层节点个数求出来
function levelNumber(node, h, a){ // node为根节点， h为节点层次，a为数组，放置各层节点个数
    if(!node){
        return;
    }
    if(!a[h]){
        a[h]=0;
    }
    a[h]++;
    
    levelNumber(node.left, h+1, a);
    levelNumber(node.right, h+1, a);
}

function BTWidth(node){
    let a = []; // a 用来放置各层节点数
    levelNumber(node, 1, a);
    let i = 0, width = 0;
    while(a[i]){ // 循环a数组，找出节点个数最多的那一层
        if(a[i] > width){
            width = a[i];
        }
        i++;
    }
    return width;
}
```



